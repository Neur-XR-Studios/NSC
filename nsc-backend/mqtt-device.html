<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MQTT Device (VR/Chair)</title>
  <script src="https://unpkg.com/paho-mqtt@1.1.0/paho-mqtt-min.js"></script>
  <script>
    // Lazy load Socket.IO for bridge mode
    function loadSocketIo(src = 'https://cdn.socket.io/4.4.1/socket.io.min.js') {
      return new Promise((resolve, reject) => {
        if (window.io) { return resolve(); }
        const s = document.createElement('script'); s.src = src; s.onload = () => resolve(); s.onerror = reject; document.head.appendChild(s);
      });
    }

    // Group/Individual session helpers
    function joinSession() {
      const sid = (document.getElementById('sessionInput').value || '').trim();
      if (!sid) { alert('Enter Session ID'); return; }
      state.sessionId = sid; setK('s_session', `Session: ${sid}`);
      try { localStorage.setItem('nsc_device_session', sid); } catch { }
      // Subscribe to group command topic
      sub(`sessions/${sid}/commands/+`);
      // Notify status with session
      const statusPayload = { deviceId: state.id, type: state.type, status: state.playing ? 'active' : 'idle', positionMs: Math.floor(state.positionMs), sessionId: sid, timestamp: new Date().toISOString() };
      try { if (bridge && connected) bridge.emit('device:status', statusPayload); } catch { }
      pub(T_status(state.id), JSON.stringify(statusPayload), true);
      // Fetch current ongoing session details and populate journeys
      try { fetchOngoingSessionDetails(); } catch {}
    }

    function leaveSession() {
      const sid = state.sessionId; state.sessionId = '';
      setK('s_session', 'Session: -');
      try { localStorage.removeItem('nsc_device_session'); } catch { }
      // No global unsubscribe to avoid removing backend subs; device will ignore further messages by not matching sessionId
      const statusPayload = { deviceId: state.id, type: state.type, status: state.playing ? 'active' : 'idle', positionMs: Math.floor(state.positionMs), sessionId: '', timestamp: new Date().toISOString() };
      try { if (bridge && connected) bridge.emit('device:status', statusPayload); } catch { }
      pub(T_status(state.id), JSON.stringify(statusPayload), true);
    }

    // Device -> Admin events (user-triggered commands)
    function sendEvent(evt, extra) {
      const payload = {
        deviceId: state.id,
        type: state.type,
        event: evt,
        positionMs: Math.floor(state.positionMs),
        sessionId: state.sessionId || '',
        journeyId: state.journeyId || '',
        timestamp: new Date().toISOString(),
        ...(extra || {})
      };
      // Via bridge
      try { if (bridge && connected) bridge.emit('mqtt_publish', { topic: `devices/${state.id}/events`, payload: JSON.stringify(payload), options: { qos: 1, retain: false } }); } catch { }
      // Also publish over MQTT topic for parity
      pub(`devices/${state.id}/events`, JSON.stringify(payload), false);
    }
  </script>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      background: #f5f7fb;
    }

    .container {
      max-width: 640px;
      margin: 0 auto;
      padding: 24px;
    }

    h1 {
      margin: 0 0 12px;
    }

    .card {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 16px;
      margin: 12px 0;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    label {
      font-size: 12px;
      color: #374151;
      display: block;
      margin-bottom: 4px;
    }

    input,
    select,
    button {
      padding: 8px 10px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 14px;
    }

    button {
      background: #2563eb;
      color: #fff;
      border: none;
      cursor: pointer;
    }

    button.danger {
      background: #dc2626;
    }

    .muted {
      color: #6b7280;
    }

    .kvs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .pill {
      padding: 2px 6px;
      background: #e5e7eb;
      border-radius: 6px;
      font-size: 12px;
    }

    .log {
      height: 160px;
      overflow: auto;
      background: #0b1020;
      color: #b2c1ff;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 8px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>MQTT Device</h1>

    <div class="card">
      <div class="row">
        <div style="flex:1; min-width:280px;">
          <label>Backend URL (Socket.IO)</label>
          <input id="mqttUrl" value="http://localhost:8001" style="width:100%" />
        </div>
        <div style="min-width:160px;">
          <label>Device Type</label>
          <select id="deviceType">
            <option value="vr">VR</option>
            <option value="chair">Chair</option>
          </select>
        </div>
        <div style="min-width:220px;">
          <label>Device ID</label>
          <input id="deviceId" placeholder="DEV_XXXX" />
        </div>
        <div style="align-self:flex-end; display:flex; gap:8px;">
          <button id="btnConnect" onclick="connectBroker()">Connect</button>
          <button id="btnDisconnect" class="danger" onclick="disconnectBroker()" disabled>Disconnect</button>
        </div>
      </div>
      <div id="connStatus" class="muted">Disconnected</div>
    </div>

    <div class="card">
      <h3>Status</h3>
      <div class="kvs">
        <span class="pill" id="s_type">Type: -</span>
        <span class="pill" id="s_id">ID: -</span>
        <span class="pill" id="s_session">Session: -</span>
        <span class="pill" id="s_peer">Peer: -</span>
        <span class="pill" id="s_journey">Journey: -</span>
      </div>
      <div class="kvs" style="margin-top:8px;">
        <span class="pill" id="s_state">State: idle</span>
        <span class="pill" id="s_pos">Position: 0 ms</span>
      </div>
      <div class="row" style="margin-top:10px; align-items:flex-end;">
        <div style="min-width:220px;">
          <label>Session ID (Group)</label>
          <input id="sessionInput" placeholder="S_XXXX" />
        </div>
        <div style="display:flex; gap:8px;">
          <button onclick="joinSession()">Join Session</button>
          <button class="danger" onclick="leaveSession()">Leave Session</button>
        </div>
        <div style="display:flex; gap:8px;">
          <button class="secondary" onclick="sendEvent('play')">Play (send)</button>
          <button class="secondary" onclick="sendEvent('pause')">Pause (send)</button>
          <button class="secondary" onclick="sendEvent('stop')">Stop (send)</button>
          <button class="secondary" onclick="sendEvent('reset')">Reset (send)</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Logs</h3>
      <div id="log" class="log"></div>
    </div>

    <div class="card">
      <h3>Journeys (from Session)</h3>
      <div id="journeysList" class="muted">No session loaded.</div>
    </div>

    <div class="card">
      <h3>Video (Test Playback)</h3>
      <div class="row" style="align-items:flex-end;">
        <div style="flex:1; min-width:300px;">
          <label>Video URL</label>
          <input id="videoUrl" placeholder="http://localhost:8001/video/<file>" style="width:100%" />
        </div>
        <div style="display:flex; gap:8px;">
          <button onclick="loadVideoUrl()">Load URL</button>
          <button onclick="clearVideoUrl()" class="danger">Clear</button>
        </div>
      </div>
      <div style="margin-top:10px;">
        <video id="player" style="width:100%; max-height:300px; background:#000;" playsinline muted controls></video>
      </div>
      <div class="muted" style="margin-top:6px; font-size:12px;">Note: This is a local test player. Devices should load their own media for a journey. Use this to verify command timing.</div>
    </div>
  </div>

  <script>
    // State
    let client = null; // Paho client (unused in forced bridge mode)
    let bridge = null; // Socket.IO client (bridge mode)
    let connected = false; let ticker = null; let mode = 'bridge';
    const state = {
      id: '', type: 'vr', name: '', sessionId: '', peer: '', journeyId: '',
      sessionType: '',
      playing: false, positionMs: 0, lastTick: 0
    };
    let player = null;
    let backendBaseUrl = '';

    // Utils
    function rand(n = 6) { return Math.random().toString(36).slice(2, 2 + n).toUpperCase(); }
    function appendRand(el) { if (!el._touched) { el.value += rand(); el._touched = true; } }
    function log(msg) { const el = document.getElementById('log'); const ts = new Date().toLocaleTimeString(); el.textContent += `[${ts}] ${msg}\n`; el.scrollTop = el.scrollHeight; console.log(msg); }
    function setK(id, v) { document.getElementById(id).textContent = v; }
    function setConnStatus(t) { document.getElementById('connStatus').textContent = t; }
    function loadVideoUrl() {
      const url = (document.getElementById('videoUrl').value || '').trim();
      if (!player) player = document.getElementById('player');
      if (!player) return;
      if (!url) { alert('Enter a video URL'); return; }
      try { player.src = url; player.load(); log('Loaded video URL'); } catch (e) { log('Video load error: ' + (e?.message || e)); }
    }
    function clearVideoUrl() {
      if (!player) player = document.getElementById('player');
      if (!player) return;
      try { player.pause(); player.removeAttribute('src'); player.load(); log('Cleared video URL'); } catch {}
    }

    // MQTT topics helpers (backend-aligned)
    function T_discovery_announce() { return 'devices/discovery/announce'; }
    function T_status(id) { return `devices/${id}/status`; }
    function T_heartbeat(id) { return `devices/${id}/heartbeat`; }
    function T_cmd_any(id) { return `devices/${id}/commands/+`; }

    function connectBroker() {
      if (connected) return;
      const url = document.getElementById('mqttUrl').value.trim();
      backendBaseUrl = url;
      // Read device type from selector; name optional/internal
      state.type = document.getElementById('deviceType').value || 'vr';
      state.id = document.getElementById('deviceId').value.trim() || ('DEV_' + rand(8));
      state.name = '';
      setK('s_type', `Type: ${state.type}`); setK('s_id', `ID: ${state.id}`);
      player = document.getElementById('player');
      if (player) {
        player.addEventListener('timeupdate', () => {
          const t = (player.currentTime || 0) * 1000;
          // Trust the video clock when playing
          if (!Number.isNaN(t)) {
            state.positionMs = t;
            setK('s_pos', `Position: ${Math.max(0, Math.floor(state.positionMs))} ms`);
          }
        });
        player.addEventListener('play', () => {
          state.playing = true; setK('s_state', 'State: playing');
          // Notify admin/backend of local action
          sendEvent('play');
        });
        player.addEventListener('pause', () => {
          state.playing = false; setK('s_state', 'State: paused');
          sendEvent('pause');
        });
        player.addEventListener('ended', () => {
          state.playing = false; setK('s_state', 'State: stopped');
          sendEvent('stop');
        });
      }
      // Restore sessionId from storage if present
      try {
        const savedSid = localStorage.getItem('nsc_device_session');
        if (savedSid) { state.sessionId = savedSid; document.getElementById('sessionInput').value = savedSid; setK('s_session', `Session: ${savedSid}`); }
      } catch { }

      // Force Socket.IO bridge mode for simplicity
      mode = 'bridge';
      loadSocketIo().then(() => {
        bridge = io(url, { transports: ['websocket'] });
        bridge.on('connect', () => {
          connected = true; setConnStatus('Connected (bridge)'); log('Bridge connected to ' + url); toggleButtons();
          // Identify to backend for immediate offline on disconnect
          bridge.emit('device:identify', { deviceId: state.id, type: state.type, name: state.name });
          // Subscribe to device command topics
          sub(T_cmd_any(state.id));
          // If we have a session, re-subscribe; also try to discover ongoing session and journeys
          if (state.sessionId) { sub(`sessions/${state.sessionId}/commands/+`); }
          try { fetchOngoingSessionDetails(); } catch {}
          // announce + status
          pub(T_discovery_announce(), JSON.stringify({ deviceId: state.id, type: state.type, name: state.name, metadata: {}, timestamp: new Date().toISOString() }), false);
          const statusPayload = { deviceId: state.id, type: state.type, status: 'active', positionMs: Math.floor(state.positionMs), sessionId: state.sessionId || '', timestamp: new Date().toISOString() };
          // MQTT status
          pub(T_status(state.id), JSON.stringify(statusPayload), true);
          // Socket.IO status fallback
          try { bridge.emit('device:status', statusPayload); } catch { }
          // Immediate heartbeat over Socket.IO and MQTT
          try { bridge.emit('device:heartbeat', { deviceId: state.id, type: state.type, status: 'active', timestamp: new Date().toISOString() }); } catch { }
          pub(T_heartbeat(state.id), JSON.stringify({ timestamp: new Date().toISOString(), status: 'active' }), false);
          startTicker();
        });
        bridge.on('disconnect', () => { connected = false; setConnStatus('Disconnected'); toggleButtons(); stopTicker(); });
        bridge.on('mqtt_message', ({ topic, payload }) => {
          const msg = { destinationName: topic, payloadString: (typeof payload === 'string' ? payload : JSON.stringify(payload || {})) };
          onMsg(msg);
        });
      }).catch(err => { log('Socket.IO load/connect failed: ' + (err?.message || err)); });
    }

    function disconnectBroker() {
      if (mode === 'bridge' && bridge) { bridge.disconnect(); bridge = null; }
      if (mode === 'mqtt' && client) { client.disconnect(); client = null; }
    }
    function toggleButtons() { document.getElementById('btnConnect').disabled = connected; document.getElementById('btnDisconnect').disabled = !connected; }

    function sub(topic) {
      if (!connected) return;
      if (mode === 'bridge') {
        bridge.emit('mqtt_subscribe', { topic, options: { qos: 1 } });
        log('Sub (bridge) ' + topic);
      } else {
        client.subscribe(topic, { qos: 1 }); log('Sub ' + topic);
      }
    }
    function pub(topic, payload, retain = false) {
      if (!connected) return;
      if (mode === 'bridge') {
        bridge.emit('mqtt_publish', { topic, payload, options: { qos: 1, retain } });
        log(`Pub (bridge) ${topic} ${payload}`);
      } else {
        const PahoMessage = Paho.Message || (Paho.MQTT && Paho.MQTT.Message); const m = new PahoMessage(payload); m.destinationName = topic; m.qos = 1; m.retained = retain; client.send(m); log(`Pub ${topic} ${payload}`);
      }
    }

    function onMsg(msg) {
      const t = msg.destinationName; const p = msg.payloadString || ''; log('Msg ' + t + ' ' + p);
      try {
        const cmdPrefix = `devices/${state.id}/commands/`;
        if (t.startsWith(cmdPrefix)) {
          const data = JSON.parse(p || '{}');
          data.command = t.substring(cmdPrefix.length);
          handleCmd(data);
        } else if (state.sessionId) {
          const sessPrefix = `sessions/${state.sessionId}/commands/`;
          if (t.startsWith(sessPrefix)) {
            const data = JSON.parse(p || '{}');
            data.command = t.substring(sessPrefix.length);
            handleCmd(data);
          }
        }
      } catch (e) { log('Parse error: ' + e.message); }
    }

    async function fetchOngoingSessionDetails() {
      if (!backendBaseUrl) return;
      try {
        const url = `${backendBaseUrl}/api/sessions?status=on_going`;
        const res = await fetch(url);
        const json = await res.json();
        const list = Array.isArray(json?.data?.data) ? json.data.data : (Array.isArray(json?.data) ? json.data : []);
        const first = Array.isArray(list) && list.length ? list[0] : null;
        if (!first) { document.getElementById('journeysList').textContent = 'No ongoing session.'; return; }
        const sid = String(first.id || '').trim();
        const stype = String(first.session_type || first?.data?.session_type || '').toLowerCase();
        state.sessionType = stype;
        if (sid && !state.sessionId) {
          state.sessionId = sid; setK('s_session', `Session: ${sid}`);
          try { localStorage.setItem('nsc_device_session', sid); } catch {}
          sub(`sessions/${sid}/commands/+`);
        }
        // For individual mode, list ALL journeys from API; for group, use session's journeys
        if (stype === 'individual') {
          try {
            const jr = await fetch(`${backendBaseUrl}/api/journeys?limit=500`);
            const jjson = await jr.json();
            const jlist = Array.isArray(jjson?.data?.data) ? jjson.data.data : (Array.isArray(jjson?.data) ? jjson.data : []);
            state.journeys = jlist || [];
          } catch (e) {
            state.journeys = [];
          }
        } else {
          const journeys = Array.isArray(first.journeys) ? first.journeys : (Array.isArray(first.data?.journeys) ? first.data.journeys : []);
          state.journeys = journeys || [];
        }
        renderJourneys();
        // For group sessions, auto-select a journey if none selected yet; for individual, let user choose
        if (stype !== 'individual') {
          let targetJid = state.journeyId;
          if (!targetJid && (state.journeys || []).length > 0) {
            const one = state.journeys[0];
            targetJid = one?.journey?.id != null ? String(one.journey.id) : '';
          }
          if (targetJid) selectAndLoadJourney(targetJid);
        }
      } catch (e) {
        log('fetchOngoingSessionDetails error: ' + (e?.message || e));
        document.getElementById('journeysList').textContent = 'Failed to load ongoing session.';
      }
    }

    function renderJourneys() {
      const el = document.getElementById('journeysList');
      const arr = state.journeys || [];
      // Update heading based on session type
      try {
        const header = el && el.parentElement ? el.parentElement.querySelector('h3') : null;
        if (header) {
          header.textContent = (state.sessionType === 'individual') ? 'Journeys (All Available)' : 'Journeys (from Session)';
        }
      } catch {}
      if (!arr.length) { el.textContent = 'No journeys in session.'; return; }
      el.innerHTML = '';
      arr.forEach((j) => {
        const jid = j?.journey?.id != null ? String(j.journey.id) : '';
        const title = j?.video?.title || j?.journey?.title || `Journey ${jid}`;
        const dur = j?.video?.duration_ms != null ? `${j.video.duration_ms} ms` : '-';
        const vurl = j?.video?.url || j?.video?.video_url || '';
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `
          <div style="flex:1; min-width:200px;">
            <div><strong>${title}</strong></div>
            <div class="muted">ID: ${jid} · Duration: ${dur}</div>
            <div class="muted" style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:520px;">${vurl || ''}</div>
          </div>
          <div style="display:flex; gap:8px;">
            <button data-jid="${jid}">Select</button>
          </div>
        `;
        const btn = row.querySelector('button');
        if (btn) btn.addEventListener('click', () => selectAndLoadJourney(jid));
        el.appendChild(row);
      });
    }

    function selectAndLoadJourney(jid) {
      state.journeyId = String(jid || '');
      setK('s_journey', `Journey: ${state.journeyId || '-'}`);
      const arr = state.journeys || [];
      const found = arr.find((j) => String(j?.journey?.id || '') === String(state.journeyId));
      const vurl = found?.video?.url || found?.video?.video_url || '';
      if (player && vurl) {
        try {
          player.pause();
          player.src = vurl;
          player.load();
          player.currentTime = 0;
          state.positionMs = 0;
          setK('s_pos', 'Position: 0 ms');
          log('Loaded journey video: ' + vurl);
          // Notify journey selection (useful in individual sessions)
          sendEvent('select_journey', { journeyId: state.journeyId });
        } catch (e) { log('Video load error: ' + (e?.message || e)); }
      }
    }

    function handleCmd(data) {
      const cmd = (data.command || data.type || '').toLowerCase();
      if (cmd === 'start' || cmd === 'play') {
        if (typeof data.positionMs === 'number') state.positionMs = data.positionMs;
        if (player && player.src) {
          try { if (typeof data.positionMs === 'number') player.currentTime = Math.max(0, data.positionMs / 1000); } catch {}
          player.play().catch(() => {});
        }
        state.playing = true; setK('s_state', 'State: playing');
      } else if (cmd === 'pause') {
        if (typeof data.positionMs === 'number') state.positionMs = data.positionMs;
        if (player && player.src) {
          try { if (typeof data.positionMs === 'number') player.currentTime = Math.max(0, data.positionMs / 1000); } catch {}
          try { player.pause(); } catch {}
        }
        state.playing = false; setK('s_state', 'State: paused');
      } else if (cmd === 'seek') {
        if (typeof data.positionMs === 'number') state.positionMs = data.positionMs;
        if (player && player.src) {
          try { player.currentTime = Math.max(0, (state.positionMs || 0) / 1000); } catch {}
        }
        setK('s_state', 'State: seeking');
      } else if (cmd === 'stop' || cmd === 'reset') {
        state.playing = false; state.positionMs = 0;
        if (player && player.src) {
          try { player.pause(); player.currentTime = 0; } catch {}
        }
        setK('s_state', 'State: stopped');
      } else if (cmd === 'calibrate') {
        setK('s_state', 'State: calibrating');
      } else if (cmd === 'join_session') {
        const sid = String(data.sessionId || data.session_id || '').trim();
        if (sid) { document.getElementById('sessionInput').value = sid; joinSession(); }
      } else if (cmd === 'leave_session') {
        leaveSession();
      } else if (cmd === 'select_journey') {
        const jid = (data.journeyId != null ? String(data.journeyId) : '').trim();
        selectAndLoadJourney(jid);
      }
      setK('s_pos', `Position: ${Math.max(0, Math.floor(state.positionMs))} ms`);
      // Also emit a status update
      const statusPayload = { deviceId: state.id, type: state.type, status: state.playing ? 'active' : 'idle', positionMs: Math.floor(state.positionMs), sessionId: state.sessionId || '', timestamp: new Date().toISOString() };
      pub(T_status(state.id), JSON.stringify(statusPayload), false);
      try { if (bridge && connected) bridge.emit('device:status', statusPayload); } catch { }
    }

    function startTicker() {
      if (ticker) return; state.lastTick = Date.now(); ticker = setInterval(() => {
        const now = Date.now(); const dt = now - state.lastTick; state.lastTick = now;
        if (player && player.src) {
          // Video clock drives position
          const ms = (player.currentTime || 0) * 1000;
          if (!Number.isNaN(ms)) state.positionMs = ms;
        } else if (state.playing) {
          state.positionMs += dt;
        }
        setK('s_pos', `Position: ${Math.max(0, Math.floor(state.positionMs))} ms`);
        // Heartbeat roughly every 15s with some jitter
      }, 1000);
    }

    // Send heartbeat every 15 seconds (Socket.IO + MQTT)
    setInterval(() => {
      if (!connected) return;
      const hb = { deviceId: state.id, type: state.type, timestamp: new Date().toISOString(), status: state.playing ? 'active' : 'idle' };
      try { if (bridge) bridge.emit('device:heartbeat', hb); } catch { }
      pub(T_heartbeat(state.id), JSON.stringify(hb), false);
    }, 15000);

    function stopTicker() { if (ticker) { clearInterval(ticker); ticker = null; } }
  </script>
</body>

</html>