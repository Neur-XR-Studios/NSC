<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MQTT Device (VR/Chair)</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script>
    // Pure MQTT implementation
    // Auto-detect WebSocket URL
    window.addEventListener('DOMContentLoaded', () => {
      const host = window.location.hostname || 'localhost';
      const urlInput = document.getElementById('mqttUrl');
      if (urlInput) urlInput.value = `ws://${host}:9001`;
    });

    // Group/Individual session helpers
    function joinSession() {
      const sid = (document.getElementById("sessionInput").value || "").trim();
      if (!sid) {
        alert("Enter Session ID");
        return;
      }
      state.sessionId = sid;
      setK("s_session", sid);
      try {
        localStorage.setItem("nsc_device_session", sid);
      } catch { }
      // Subscribe to group command topic
      sub(`sessions/${sid}/commands/+`);
      // Notify status with session
      const statusPayload = {
        deviceId: state.id,
        type: state.type,
        status: state.playing ? "active" : "idle",
        positionMs: Math.floor(state.positionMs),
        sessionId: sid,
        timestamp: new Date().toISOString(),
      };
      try {
        if (bridge && connected) bridge.emit("device:status", statusPayload);
      } catch { }
      pub(T_status(state.id), JSON.stringify(statusPayload), true);
      // Fetch current ongoing session details and populate journeys
      try {
        fetchOngoingSessionDetails();
      } catch { }
    }

    function leaveSession() {
      const sid = state.sessionId;
      state.sessionId = "";
      setK("s_session", "-");
      try {
        localStorage.removeItem("nsc_device_session");
      } catch { }
      // No global unsubscribe to avoid removing backend subs; device will ignore further messages by not matching sessionId
      const statusPayload = {
        deviceId: state.id,
        type: state.type,
        status: state.playing ? "active" : "idle",
        positionMs: Math.floor(state.positionMs),
        sessionId: "",
        timestamp: new Date().toISOString(),
      };
      try {
        if (bridge && connected) bridge.emit("device:status", statusPayload);
      } catch { }
      pub(T_status(state.id), JSON.stringify(statusPayload), true);
    }

    // Device -> Admin events (user-triggered commands)
    function sendEvent(evt, extra) {
      const payload = {
        deviceId: state.id,
        type: state.type,
        event: evt,
        positionMs: Math.floor(state.positionMs),
        sessionId: state.sessionId || "",
        journeyId: state.journeyId || "",
        timestamp: new Date().toISOString(),
        ...(extra || {}),
      };
      // Via bridge
      try {
        if (bridge && connected)
          bridge.emit("mqtt_publish", {
            topic: `devices/${state.id}/events`,
            payload: JSON.stringify(payload),
            options: { qos: 1, retain: false },
          });
      } catch { }
      // Also publish over MQTT topic for parity
      console.log("publishing", payload);
      pub(`devices/${state.id}/events`, JSON.stringify(payload), false);
    }
  </script>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      height: 100vh;
      overflow: hidden;
      padding: 12px;
    }

    .container {
      height: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 12px 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      flex-shrink: 0;
    }

    .header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      display: inline;
    }

    .header .subtitle {
      color: #6b7280;
      font-size: 12px;
      margin: 0;
      display: inline;
      margin-left: 12px;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 350px 1fr 300px;
      gap: 12px;
      flex: 1;
      min-height: 0;
    }

    .left-panel,
    .center-panel,
    .right-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: #1f2937;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    .card-title::before {
      content: "";
      width: 3px;
      height: 16px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 2px;
    }

    .form-group {
      margin-bottom: 10px;
    }

    label {
      font-size: 11px;
      font-weight: 500;
      color: #374151;
      display: block;
      margin-bottom: 4px;
    }

    input,
    select {
      width: 100%;
      padding: 6px 10px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 13px;
      transition: all 0.2s;
      background: white;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .button-group {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-success {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
    }

    .btn-secondary {
      background: #f3f4f6;
      color: #374151;
      border: 2px solid #e5e7eb;
    }

    .btn-secondary:hover {
      background: #e5e7eb;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: #f3f4f6;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 500;
      color: #374151;
    }

    .status-badge.connected {
      background: #d1fae5;
      color: #065f46;
    }

    .status-badge.connected::before {
      content: "";
      width: 8px;
      height: 8px;
      background: #10b981;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    .status-badge.disconnected::before {
      content: "";
      width: 8px;
      height: 8px;
      background: #6b7280;
      border-radius: 50%;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
      flex: 1;
      overflow-y: auto;
    }

    .info-item {
      background: #f9fafb;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }

    .info-label {
      font-size: 9px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
    }

    .info-value {
      font-size: 12px;
      font-weight: 600;
      color: #1f2937;
      word-break: break-all;
    }

    .log {
      flex: 1;
      overflow: auto;
      background: #1f2937;
      color: #e5e7eb;
      font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, "Courier New", monospace;
      font-size: 10px;
      padding: 10px;
      border-radius: 8px;
      line-height: 1.4;
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .log::-webkit-scrollbar {
      width: 8px;
    }

    .log::-webkit-scrollbar-track {
      background: #374151;
      border-radius: 4px;
    }

    .log::-webkit-scrollbar-thumb {
      background: #6b7280;
      border-radius: 4px;
    }

    .journey-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 8px;
      flex: 1;
      overflow-y: auto;
      align-content: start;
    }

    .journey-card {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 10px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .journey-card:hover {
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
    }

    .journey-card.selected {
      border-color: #667eea;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    }

    .journey-thumbnail {
      width: 100%;
      height: 70px;
      object-fit: cover;
      border-radius: 6px;
      margin-bottom: 6px;
      background: #f3f4f6;
    }

    .journey-title {
      font-size: 11px;
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 2px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .journey-id {
      font-size: 9px;
      color: #6b7280;
    }

    video {
      width: 100%;
      height: 100%;
      border-radius: 10px;
      background: #000;
      object-fit: contain;
    }

    .video-container {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #9ca3af;
    }

    .empty-state svg {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      opacity: 0.5;
    }

    .divider {
      height: 1px;
      background: #e5e7eb;
      margin: 20px 0;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: #f3f4f6;
      border-radius: 16px;
      font-size: 11px;
      font-weight: 500;
      color: #374151;
    }

    .divider {
      height: 1px;
      background: #e5e7eb;
      margin: 10px 0;
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üéÆ Device Simulator</h1>
      <span class="subtitle">VR Headset & Motion Chair Testing Interface</span>
    </div>

    <!-- Main 3-Column Grid -->
    <div class="main-grid">
      <!-- LEFT PANEL -->
      <div class="left-panel">
        <!-- Connection -->
        <div class="card" style="flex-shrink: 0">
          <h2 class="card-title">Connection</h2>
          <div class="form-group">
            <label>MQTT Broker URL</label>
            <input id="mqttUrl" placeholder="ws://localhost:9001" />
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px">
            <div class="form-group" style="margin: 0">
              <label>Type</label>
              <select id="deviceType">
                <option value="vr">ü•Ω VR</option>
                <option value="chair">üí∫ Chair</option>
              </select>
            </div>
            <div class="form-group" style="margin: 0">
              <label>Device ID</label>
              <input id="deviceId" placeholder="001" value="001" />
            </div>
          </div>
          <div class="button-group">
            <button id="btnConnect" class="btn-success" onclick="connectBroker()">‚ö° Connect</button>
            <button id="btnDisconnect" class="btn-danger" onclick="disconnectBroker()" disabled>‚èπ Disconnect</button>
          </div>
          <div style="margin-top: 8px">
            <div id="connStatus" class="status-badge disconnected">Disconnected</div>
          </div>
        </div>

        <!-- Device Info -->
        <div class="card" style="flex: 1; min-height: 0">
          <h2 class="card-title">Device Info</h2>
          <div class="info-grid">
            <div class="info-item">
              <div class="info-label">Type</div>
              <div class="info-value" id="s_type">-</div>
            </div>
            <div class="info-item">
              <div class="info-label">Device ID</div>
              <div class="info-value" id="s_id">-</div>
            </div>
            <div class="info-item">
              <div class="info-label">Session</div>
              <div class="info-value" id="s_session">-</div>
            </div>
            <div class="info-item">
              <div class="info-label">Peer</div>
              <div class="info-value" id="s_peer">-</div>
            </div>
            <div class="info-item">
              <div class="info-label">Journey</div>
              <div class="info-value" id="s_journey">-</div>
            </div>
            <div class="info-item">
              <div class="info-label">State</div>
              <div class="info-value" id="s_state">idle</div>
            </div>
            <div class="info-item">
              <div class="info-label">Position</div>
              <div class="info-value" id="s_pos">0:00</div>
            </div>
            <div class="info-item">
              <div class="info-label">Peer Status</div>
              <div class="info-value" id="s_peer_status">‚ö™ Unknown</div>
            </div>
            <div class="info-item">
              <div class="info-label">Sync Offset</div>
              <div class="info-value" id="s_sync_offset">0ms</div>
            </div>
            <div class="info-item">
              <div class="info-label">Sync Health</div>
              <div class="info-value" id="s_sync_health">‚ö™</div>
            </div>
          </div>
        </div>

        <!-- Session Management -->
        <div class="card" style="flex-shrink: 0">
          <h2 class="card-title">Session</h2>
          <div class="form-group">
            <label>Session ID</label>
            <input id="sessionInput" placeholder="S_XXXX" />
          </div>
          <div class="button-group" style="margin-bottom: 8px">
            <button class="btn-success" onclick="joinSession()">‚úì Join</button>
            <button class="btn-danger" onclick="leaveSession()">‚úó Leave</button>
          </div>
          <div class="divider"></div>
          <div class="button-group" style="margin-bottom: 8px">
            <button class="btn-primary" onclick="forceResync()">üîÑ Re-sync</button>
          </div>
          <div class="button-group">
            <button class="btn-secondary" onclick="sendEvent('play')">‚ñ∂</button>
            <button class="btn-secondary" onclick="sendEvent('pause')">‚è∏</button>
            <button class="btn-secondary" onclick="sendEvent('stop')">‚èπ</button>
            <button class="btn-secondary" onclick="sendEvent('reset')">‚Üª</button>
          </div>
        </div>
      </div>

      <!-- CENTER PANEL -->
      <div class="center-panel">
        <!-- Video Player -->
        <div class="card" style="flex: 2; min-height: 0">
          <h2 class="card-title">Video Player</h2>
          <!-- <div class="form-group">
            <label>Video URL</label>
            <input id="videoUrl" placeholder="http://localhost:8001/video/filename.mp4" />
          </div>
          <div class="button-group" style="margin-bottom: 10px;">
            <button class="btn-primary" onclick="loadVideoUrl()">üìπ Load</button>
            <button class="btn-danger" onclick="clearVideoUrl()">üóë Clear</button>
          </div> -->
          <div class="video-container">
            <video id="player" playsinline muted controls></video>
          </div>
        </div>

        <!-- Logs -->
        <div class="card" style="flex: 1; min-height: 0">
          <h2 class="card-title">System Logs</h2>
          <div id="log" class="log"></div>
        </div>
      </div>

      <!-- RIGHT PANEL -->
      <div class="right-panel">
        <!-- Journeys -->
        <div class="card" style="flex: 1; min-height: 0">
          <h2 class="card-title">Journeys</h2>
          <div id="journeysList" class="empty-state"
            style="flex: 1; display: flex; align-items: center; justify-content: center; flex-direction: column">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"
              style="width: 32px; height: 32px; margin-bottom: 8px; opacity: 0.5">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M7 4v16M17 4v16M3 8h4m10 0h4M3 12h18M3 16h4m10 0h4M4 20h16a1 1 0 001-1V5a1 1 0 00-1-1H4a1 1 0 00-1 1v14a1 1 0 001 1z" />
            </svg>
            <div style="font-size: 11px">No session loaded</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // State
    let client = null; // Paho client (unused in forced bridge mode)
    let bridge = null; // Socket.IO client (bridge mode)
    let connected = false;
    let ticker = null;
    let mode = "bridge";
    const state = {
      id: "",
      type: "vr",
      name: "",
      sessionId: "",
      peer: "",
      journeyId: "",
      sessionType: "",
      playing: false,
      positionMs: 0,
      lastTick: 0,
      // Peer monitoring
      peerDeviceId: "",
      peerStatus: "unknown",
      peerLastSeen: null,
      peerPositionMs: 0,
      syncOffset: 0, // milliseconds difference (positive = we're ahead)
      syncHealth: "unknown", // "good" | "warning" | "critical" | "unknown"
    };
    let player = null;
    let backendBaseUrl = "";

    // Utils
    function rand(n = 6) {
      return Math.random()
        .toString(36)
        .slice(2, 2 + n)
        .toUpperCase();
    }
    function appendRand(el) {
      if (!el._touched) {
        el.value += rand();
        el._touched = true;
      }
    }
    function log(msg) {
      const el = document.getElementById("log");
      const ts = new Date().toLocaleTimeString();
      el.textContent += `[${ts}] ${msg}\n`;
      el.scrollTop = el.scrollHeight;
      console.log(msg);
    }
    function setK(id, v) {
      const el = document.getElementById(id);
      if (el) el.textContent = v;
    }
    function setConnStatus(t, isConnected) {
      const el = document.getElementById("connStatus");
      if (!el) return;
      el.textContent = t;
      el.className = isConnected ? "status-badge connected" : "status-badge disconnected";
    }
    function loadVideoUrl() {
      const url = (document.getElementById("videoUrl").value || "").trim();
      if (!player) player = document.getElementById("player");
      if (!player) return;
      if (!url) {
        alert("Enter a video URL");
        return;
      }
      try {
        player.src = url;
        player.load();
        log("Loaded video URL");
      } catch (e) {
        log("Video load error: " + (e?.message || e));
      }
    }
    function clearVideoUrl() {
      if (!player) player = document.getElementById("player");
      if (!player) return;
      try {
        player.pause();
        player.removeAttribute("src");
        player.load();
        log("Cleared video URL");
      } catch { }
    }

    // MQTT topics helpers (backend-aligned)
    function T_discovery_announce() {
      return "devices/discovery/announce";
    }
    function T_status(id) {
      return `devices/${id}/status`;
    }
    function T_heartbeat(id) {
      return `devices/${id}/heartbeat`;
    }
    function T_cmd_any(id) {
      return `devices/${id}/commands/+`;
    }

    async function connectBroker() {
      if (connected || client) {
        log("Already connected or connecting...");
        return;
      }
      const url = document.getElementById("mqttUrl").value.trim();
      backendBaseUrl = url.replace(/^ws/, "http").replace(/:9001$/, ":8001"); // Fallback for API calls

      // Read device type and ID
      state.type = document.getElementById("deviceType").value || "vr";
      state.id = document.getElementById("deviceId").value.trim() || "DEV_" + rand(8);
      state.name = "";
      setK("s_type", state.type === "vr" ? "ü•Ω VR" : "üí∫ Chair");
      setK("s_id", state.id);
      player = document.getElementById("player");

      // Replace the entire video event listener section with this:

      if (player) {
        let isProcessingCommand = false;
        let lastSentPosition = 0;
        let lastSentEvent = "";
        let lastEventTime = 0;
        const EVENT_DEBOUNCE_MS = 500; // Minimum time between same events

        player.addEventListener("play", () => {
          const now = Date.now();
          if (isProcessingCommand || (lastSentEvent === "play" && now - lastEventTime < EVENT_DEBOUNCE_MS)) {
            return;
          }

          console.log("%cplaying", "color:green; font-size:18px;");
          state.playing = true;
          setK("s_state", "‚ñ∂ Playing");
          lastSentEvent = "play";
          lastEventTime = now;
          sendEvent("play");
        });

        player.addEventListener("pause", () => {
          const now = Date.now();
          if (isProcessingCommand || (lastSentEvent === "pause" && now - lastEventTime < EVENT_DEBOUNCE_MS)) {
            return;
          }

          console.log("%cpaused", "color:orange; font-size:18px;");
          state.playing = false;
          setK("s_state", "‚è∏ Paused");
          lastSentEvent = "pause";
          lastEventTime = now;
          sendEvent("pause");
        });

        player.addEventListener("ended", () => {
          console.log("%cended", "color:red; font-size:18px;");
          state.playing = false;
          setK("s_state", "‚èπ Stopped");
          sendEvent("stop");
        });

        player.addEventListener("seeking", () => {
          // Only send seek events for user-initiated seeks, not automatic ones
          if (isProcessingCommand) {
            return;
          }

          const currentTime = Math.floor(player.currentTime * 1000);
          // Only send if seek is significant (more than 1 second difference)
          if (Math.abs(currentTime - lastSentPosition) > 1000) {
            console.log("%cseeking", "color:blue; font-size:18px;");
            sendEvent("seek", { positionMs: currentTime });
            lastSentPosition = currentTime;
          }
        });

        player.addEventListener("timeupdate", () => {
          // Update internal state but don't send events for time updates
          const currentTime = (player.currentTime || 0) * 1000;
          if (!Number.isNaN(currentTime)) {
            state.positionMs = currentTime;
            const pos = Math.max(0, Math.floor(state.positionMs));
            const sec = Math.floor(pos / 1000);
            const min = Math.floor(sec / 60);
            const s = sec % 60;
            setK("s_pos", `${min}:${s.toString().padStart(2, "0")}`);
          }
        });
      }
      // Restore sessionId from storage if present
      try {
        const savedSid = localStorage.getItem("nsc_device_session");
        if (savedSid) {
          state.sessionId = savedSid;
          document.getElementById("sessionInput").value = savedSid;
          setK("s_session", `Session: ${savedSid}`);
        }
      } catch { }

      log(`Connecting to ${url}...`);
      setConnStatus("Connecting...", false);

      try {
        // Connect options with Last Will Testament
        const options = {
          clientId: state.id + '_' + Date.now(), // Add timestamp to ensure unique client ID
          clean: true,
          reconnectPeriod: 5000, // Reconnect every 5 seconds instead of default 1 second
          connectTimeout: 30000, // 30 second timeout
          keepalive: 60, // Send keepalive every 60 seconds
          will: {
            topic: `devices/${state.id}/lwt`,
            payload: 'offline',
            qos: 1,
            retain: true
          }
        };

        client = mqtt.connect(url, options);

        client.on("connect", () => {
          connected = true;
          mode = "mqtt";
          setConnStatus("Connected (MQTT)", true);
          log("Connected to MQTT broker");
          toggleButtons();
          startTicker();

          // Subscribe to topics
          sub(T_cmd_any(state.id));
          if (state.sessionId) sub(`sessions/${state.sessionId}/commands/+`);

          // Announce device (Retained)
          const announcePayload = {
            deviceId: state.id,
            type: state.type,
            name: state.id,
            display_name: state.id,
            status: "idle",
            online: true
          };
          pub(T_discovery_announce(), JSON.stringify(announcePayload), true);

          // Publish initial status
          const statusPayload = {
            deviceId: state.id,
            type: state.type,
            status: "idle",
            positionMs: 0,
            sessionId: state.sessionId || "",
            timestamp: new Date().toISOString(),
          };
          pub(T_status(state.id), JSON.stringify(statusPayload), true);

          // Clear LWT (mark as online)
          pub(`devices/${state.id}/lwt`, 'online', true);
        });

        client.on("message", (topic, message) => {
          const msg = message.toString();
          log(`Msg ${topic} ${msg}`);
          try {
            const cmdPrefix = `devices/${state.id}/commands/`;
            if (topic.startsWith(cmdPrefix)) {
              const data = JSON.parse(msg || "{}");
              data.command = topic.substring(cmdPrefix.length);
              handleCmd(data);
            } else if (state.sessionId) {
              const sessPrefix = `sessions/${state.sessionId}/commands/`;
              if (topic.startsWith(sessPrefix)) {
                const data = JSON.parse(msg || "{}");
                data.command = topic.substring(sessPrefix.length);
                handleCmd(data);
              }
            }
          } catch (e) {
            log("Msg parse error: " + e.message);
          }
        });

        client.on("error", (err) => {
          log("MQTT Error: " + err.message);
          setConnStatus("Error", false);
          // Don't set connected to false here, let close event handle it
        });

        client.on("close", () => {
          if (connected) {
            connected = false;
            setConnStatus("Disconnected", false);
            log("MQTT Disconnected");
            toggleButtons();
            stopTicker();
          }
        });

        client.on("offline", () => {
          log("MQTT Client went offline");
          setConnStatus("Offline (Reconnecting...)", false);
        });

        client.on("reconnect", () => {
          log("MQTT Attempting to reconnect...");
          setConnStatus("Reconnecting...", false);
        });

      } catch (e) {
        log("Connection error: " + e.message);
        setConnStatus("Error", false);
      }
    }

    function disconnectBroker() {
      if (client) {
        try {
          // Publish offline status before disconnecting
          pub(`devices/${state.id}/lwt`, 'offline', true);
          // Force disconnect without reconnecting
          client.end(true);
        } catch (e) {
          log("Disconnect error: " + e.message);
        }
        client = null;
      }
      connected = false;
      setConnStatus("Disconnected", false);
      toggleButtons();
      stopTicker();
    }
    function toggleButtons() {
      document.getElementById("btnConnect").disabled = connected;
      document.getElementById("btnDisconnect").disabled = !connected;
    }

    function sub(topic) {
      if (!connected || !client) return;
      client.subscribe(topic, { qos: 1 }, (err) => {
        if (!err) log("Sub " + topic);
        else log("Sub error: " + err.message);
      });
    }

    function pub(topic, payload, retain = false) {
      if (!connected || !client) return;
      client.publish(topic, payload, { qos: 1, retain }, (err) => {
        if (err) log("Pub error: " + err.message);
      });
    }



    async function fetchOngoingSessionDetails() {
      if (!backendBaseUrl) return;
      try {
        const url = `${backendBaseUrl}/api/sessions?status=on_going`;
        const res = await fetch(url);
        const json = await res.json();
        const list = Array.isArray(json?.data?.data) ? json.data.data : Array.isArray(json?.data) ? json.data : [];
        const first = Array.isArray(list) && list.length ? list[0] : null;
        if (!first) {
          document.getElementById("journeysList").textContent = "No ongoing session.";
          return;
        }
        const sid = String(first.id || "").trim();
        const stype = String(first.session_type || first?.data?.session_type || "").toLowerCase();
        state.sessionType = stype;
        if (sid && !state.sessionId) {
          state.sessionId = sid;
          setK("s_session", sid);
          try {
            localStorage.setItem("nsc_device_session", sid);
          } catch { }
          sub(`sessions/${sid}/commands/+`);
        }
        // For individual mode, list ALL journeys from API; for group, use session's journeys
        if (stype === "individual") {
          try {
            const jr = await fetch(`${backendBaseUrl}/api/journeys?limit=500`);
            const jjson = await jr.json();
            const jlist = Array.isArray(jjson?.data?.data)
              ? jjson.data.data
              : Array.isArray(jjson?.data)
                ? jjson.data
                : [];
            state.journeys = jlist || [];
          } catch (e) {
            state.journeys = [];
          }
        } else {
          const journeys = Array.isArray(first.journeys)
            ? first.journeys
            : Array.isArray(first.data?.journeys)
              ? first.data.journeys
              : [];
          state.journeys = journeys || [];
        }
        renderJourneys();
        // For group sessions, auto-select a journey if none selected yet; for individual, let user choose
        if (stype !== "individual") {
          let targetJid = state.journeyId;
          if (!targetJid && (state.journeys || []).length > 0) {
            const one = state.journeys[0];
            targetJid = one?.journey?.id != null ? String(one.journey.id) : "";
          }
          if (targetJid) selectAndLoadJourney(targetJid);
        }
      } catch (e) {
        log("fetchOngoingSessionDetails error: " + (e?.message || e));
        document.getElementById("journeysList").textContent = "Failed to load ongoing session.";
      }
    }

    function renderJourneys() {
      const el = document.getElementById("journeysList");
      const arr = state.journeys || [];
      if (!arr.length) {
        el.innerHTML = `
          <div style="flex: 1; display: flex; align-items: center; justify-content: center; flex-direction: column; color: #9ca3af;">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 32px; height: 32px; margin-bottom: 8px; opacity: 0.5;">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4v16M17 4v16M3 8h4m10 0h4M3 12h18M3 16h4m10 0h4M4 20h16a1 1 0 001-1V5a1 1 0 00-1-1H4a1 1 0 00-1 1v14a1 1 0 001 1z" />
            </svg>
            <div style="font-size: 11px;">No journeys available</div>
          </div>
        `;
        return;
      }
      // Render as grid of cards
      let html = '<div class="journey-grid">';
      arr.forEach((j) => {
        const jid = String(j?.journey?.id || j?.video?.id || "");
        const title = String(j?.journey?.title || j?.video?.title || "Untitled");
        const thumbnail = j?.video?.thumbnail_url || "";
        const selected = String(state.journeyId) === jid;
        const selectedClass = selected ? "selected" : "";
        html += `<div class="journey-card ${selectedClass}" onclick="selectAndLoadJourney('${jid}')">`;
        if (thumbnail) {
          html += `<img src="${thumbnail}" class="journey-thumbnail" alt="${title}" />`;
        } else {
          html += `<div class="journey-thumbnail" style="display:flex;align-items:center;justify-content:center;color:#9ca3af;">üìπ</div>`;
        }
        html += `<div class="journey-title">${title}</div>`;
        html += `<div class="journey-id">ID: ${jid}</div>`;
        html += `</div>`;
      });
      html += "</div>";
      el.innerHTML = html;
    }

    function selectAndLoadJourney(jid) {
      state.journeyId = String(jid || "");
      setK("s_journey", state.journeyId || "-");
      const arr = state.journeys || [];
      const found = arr.find((j) => String(j?.journey?.id || "") === String(state.journeyId));
      const vurl = found?.video?.url || found?.video?.video_url || "";
      if (player && vurl) {
        try {
          player.pause();
          player.src = vurl;
          player.load();
          player.currentTime = 0;
          state.positionMs = 0;
          setK("s_pos", "Position: 0 ms");
          log("Loaded journey video: " + vurl);
          // Notify journey selection (useful in individual sessions)
          sendEvent("select_journey", { journeyId: state.journeyId });
        } catch (e) {
          log("Video load error: " + (e?.message || e));
        }
      }
    }

    function handleCmd(data) {
      const cmd = (data.command || data.type || "").toLowerCase();
      const cmdJourneyId = data.journeyId != null ? String(data.journeyId) : null;

      // Set flag to prevent event feedback
      isProcessingCommand = true;

      if (cmd === "start" || cmd === "play") {
        if (cmdJourneyId && cmdJourneyId !== state.journeyId) {
          selectAndLoadJourney(cmdJourneyId);
        }
        if (typeof data.positionMs === "number") state.positionMs = data.positionMs;
        if (player && player.src) {
          try {
            if (typeof data.positionMs === "number") {
              player.currentTime = Math.max(0, data.positionMs / 1000);
              lastSentPosition = data.positionMs;
            }
          } catch { }
          player.play().catch(() => { });
        }
        state.playing = true;
        setK("s_state", "‚ñ∂ Playing");
        lastSentEvent = "play";
      } else if (cmd === "pause") {
        if (typeof data.positionMs === "number") {
          state.positionMs = data.positionMs;
          lastSentPosition = data.positionMs;
        }
        if (player && player.src) {
          try {
            if (typeof data.positionMs === "number") {
              player.currentTime = Math.max(0, data.positionMs / 1000);
            }
          } catch { }
          player.pause();
        }
        state.playing = false;
        setK("s_state", "‚è∏ Paused");
        lastSentEvent = "pause";
      } else if (cmd === "seek") {
        if (typeof data.positionMs === "number") {
          state.positionMs = data.positionMs;
          lastSentPosition = data.positionMs;
        }
        if (player && player.src) {
          player.currentTime = Math.max(0, (state.positionMs || 0) / 1000);
        }
        setK("s_state", "‚è© Seeking");
      } else if (cmd === "stop" || cmd === "reset") {
        state.playing = false;
        state.positionMs = 0;
        lastSentPosition = 0;
        if (player && player.src) {
          player.pause();
          player.currentTime = 0;
        }
        setK("s_state", "State: stopped");
        lastSentEvent = "stop";
      } else if (cmd === "calibrate") {
        setK("s_state", "üîß Calibrating");
      } else if (cmd === "join_session") {
        const sid = String(data.sessionId || data.session_id || "").trim();
        if (sid) {
          document.getElementById("sessionInput").value = sid;
          joinSession();
        }
      } else if (cmd === "leave_session") {
        leaveSession();
      } else if (cmd === "select_journey") {
        const jid = (data.journeyId != null ? String(data.journeyId) : "").trim();
        const lang = (data.language || "").trim();
        log(`Selecting journey ${jid} with language: ${lang || "default"}`);
        selectAndLoadJourney(jid);
        // Note: HTML simulator doesn't have full audio track support
        // Unity will use the language parameter to select the correct audio track
      }
      setK("s_pos", `Position: ${Math.max(0, Math.floor(state.positionMs))} ms`);
      // Also emit a status update
      const statusPayload = {
        deviceId: state.id,
        type: state.type,
        status: state.playing ? "active" : "idle",
        positionMs: Math.floor(state.positionMs),
        sessionId: state.sessionId || "",
        timestamp: new Date().toISOString(),
      };
      pub(T_status(state.id), JSON.stringify(statusPayload), false);
      setTimeout(() => {
        isProcessingCommand = false;
      }, 100);
      try {
        if (bridge && connected) bridge.emit("device:status", statusPayload);
      } catch { }
    }

    function startTicker() {
      if (ticker) return;
      state.lastTick = Date.now();
      ticker = setInterval(() => {
        const now = Date.now();
        const dt = now - state.lastTick;
        state.lastTick = now;
        if (player && player.src) {
          // Video clock drives position
          const ms = (player.currentTime || 0) * 1000;
          if (!Number.isNaN(ms)) state.positionMs = ms;
        } else if (state.playing) {
          state.positionMs += dt;
        }
        setK("s_pos", `Position: ${Math.max(0, Math.floor(state.positionMs))} ms`);
        // Heartbeat roughly every 15s with some jitter
      }, 1000);
    }

    // Send heartbeat every 5 seconds (Socket.IO + MQTT) for real-time status
    setInterval(() => {
      if (!connected) return;
      const hb = {
        deviceId: state.id,
        type: state.type,
        timestamp: new Date().toISOString(),
        status: state.playing ? "active" : "idle",
      };
      try {
        if (bridge) bridge.emit("device:heartbeat", hb);
      } catch { }
      pub(T_heartbeat(state.id), JSON.stringify(hb), false);
    }, 5000);

    function stopTicker() {
      if (ticker) {
        clearInterval(ticker);
        ticker = null;
      }
    }
  </script>
</body>

</html>